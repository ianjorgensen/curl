var net = require('net');
var common = require('common');
var crypto = require('crypto');
var createRouter = require('router').create;

var Parser = common.emitter(function() {
	this.buffer = '';
	this.start = 0;
	this.framing = false;
});

Parser.prototype.parse = function(data) {
	var index = -1;
	var last = 0;
	
	while ((index = data.indexOf(this.framing ? '\ufffd' : '\u0000', last)) > -1) {
		if (this.framing) {
			this.emit('message', this.buffer.substring(this.start)+data.substring(last, index));
			this.buffer = '';
		}
		
		this.start = last = index+1;
		this.framing = !this.framing;
	}
	if (this.framing && last <= data.length) {
		this.buffer += data;
	}
};

var JSONSocket = common.emitter(function(socket) {
	this.socket = socket;
	this.buffer = [];
	
	socket.setEncoding('utf-8');
	
	var self = this;
	var parser = new Parser();
	
	parser.on('message', function(message) {
		self.emit('message', JSON.parse(message));
	});
	
	if (socket.readyState === 'open') {
		this.send = this._write;
	} else {
		socket.on('connect', function() {
			self.send = self._write;
			while (self.buffer.length) {
				self._write(self.buffer.shift());
			}
			self.emit('open');
		});
	}
	
	var onclose = common.once(function() {
		self.emit('close');
	});
	
	socket.on('end', function() {
		socket.destroy();
	});
	
	socket.on('error', onclose);
	socket.on('close', onclose);
	
	socket.on('data', function(data) {
		parser.parse(data);
	});
});

JSONSocket.prototype.send = function(data) {
	this.buffer.push(data);
};

JSONSocket.prototype._write = function(data) {
	this.socket.write('\u0000', 'binary');
	this.socket.write(JSON.stringify(data));
	this.socket.write('\uffff', 'binary');
};

var normalize = function(host) {
	var matches = (host || 'localhost').match(/([^:]+):?(\d*)/).slice(1);
	
	return {
		host : matches[0],
		port : parseInt(matches[1] || '10547',10)
	};
};

exports.connect = function(host) {
	var host = normalize(host);
	var socket = net.createConnection(host.port,host.host);
	
	return new JSONSocket(socket);
};

exports.createServer = function(onsocket) {
	var server = net.createServer(function(socket) {
		onsocket(new JSONSocket(socket));
	});
	
	var that = {};
	
	that.listen = function(port, callback) {
		if (typeof port !== 'number') {
			callback = port;
			port = 10547;
		}
		server.listen(port, callback);
	};
	that.close = function(callback) {
		server.close(callback);
	};
	
	return that;
};

// Browser interface

var onwebsocket = function(callback) {	
	// TODO: add protocal 6
	var sign = function(request, head) {
		var md5 = crypto.createHash('md5');
		var k1 = request.headers['sec-websocket-key1'];
		var k2 = request.headers['sec-websocket-key2'];

		[k1, k2].forEach(function(k){
			var n = parseInt(k.replace(/[^\d]/g, ''), 10);
			var spaces = k.replace(/[^ ]/g, '').length;

			if (spaces === 0 || n % spaces !== 0){
				return null;
			}
			n /= spaces;
			md5.update(String.fromCharCode(
				n >> 24 & 0xFF,
				n >> 16 & 0xFF,
				n >> 8  & 0xFF,
				n       & 0xFF));
		});
		md5.update(head.toString('binary'));
		return md5.digest('binary');	
	};

	return function(request, connection, head) {
		connection.setNoDelay(true);	

		var sec = 'sec-websocket-key1' in request.headers ? 'Sec-' : '';
		var token = sec && sign(request, head);

		if (token === null) {
			connection.destroy();
			return;
		}

		var handshake = [
			'HTTP/1.1 101 Web Socket Protocol Handshake', 
			'Upgrade: WebSocket', 
			'Connection: Upgrade',
			sec + 'WebSocket-Origin: ' + request.headers.origin || 'null',
			sec + 'WebSocket-Location: ws://' + request.headers.host + (request.realUrl || request.url)
		].join('\r\n');

		connection.write(handshake + '\r\n\r\n' + token, 'binary');	
		callback(connection);
	};
};

exports.listen = function(router, onsocket) {
	if (typeof router === 'number') {
		var port = router;
		
		router = exports.listen(createRouter(), onsocket);
		router.listen(port);
		
		return router;
	}
	router = createRouter(router);
	
	router.upgrade('/json-socket', onwebsocket(function(connection) {
		onsocket(new JSONSocket(connection));
	}));
	
	return router;
};